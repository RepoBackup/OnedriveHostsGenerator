mod utils;

use chrono::{Local, Utc};
use chrono_tz::Asia::Shanghai;
use once_cell::sync::Lazy;
use std::collections::HashMap;
use std::fmt;
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use std::time::Instant;
use tokio::task::JoinSet;
use trust_dns_resolver::config::*;
use trust_dns_resolver::{AsyncResolver, TokioAsyncResolver};

use crate::utils::StringLine;

include!(concat!(env!("OUT_DIR"), "/domains.rs"));

static RESOLVER: Lazy<TokioAsyncResolver> = Lazy::new(|| {
    let mut options = ResolverOpts::default();
    options.ip_strategy = LookupIpStrategy::Ipv4AndIpv6;
    options.num_concurrent_reqs = 2;
    let mut config = NameServerConfigGroup::quad9_https();
    config.merge(NameServerConfigGroup::cloudflare_https());

    AsyncResolver::tokio(ResolverConfig::from_parts(None, vec![], config), options).unwrap()
});

fn trim_mean(numbers: &mut Vec<u64>, trimming_percentage: f64) -> u64 {
    numbers.sort();

    let trim_count =
        ((numbers.len() as f64) * (trimming_percentage / 100.0) / 2.0).round() as usize;

    numbers.drain(0..trim_count);
    numbers.drain((numbers.len() - trim_count)..);

    let sum: u64 = numbers.iter().sum();

    sum / numbers.len() as u64
}

pub async fn render(ipv4: bool, ipv6: bool, single: bool) -> (String, u64) {
    let mut header = String::new();
    header.push_str_line("####### Onenote Hosts Start #######");
    header.push_str_line(
        "# This file is generated by https://github.com/Zxilly/OnedriveHostsGenerator",
    );

    let now = Utc::now().with_timezone(&Shanghai);

    header.push_str_line(&format!(
        "# Generate time: {}",
        now.format("%Y-%m-%d %H:%M:%S")
    ));

    let mut content = String::new();

    let mut v4_ips: HashMap<&str, Vec<Ipv4Addr>> = HashMap::new();
    let mut v6_ips: HashMap<&str, Vec<Ipv6Addr>> = HashMap::new();

    let mut max_v4_domain_len = 0;
    let mut max_v6_domain_len = 0;
    let mut max_v4_ip_len = 0;
    let mut max_v6_ip_len = 0;

    let mut tasks = JoinSet::new();

    for domain in DOMAIN_LIST {
        tasks.spawn(async move {
            let ret = RESOLVER.lookup_ip(domain).await;
            (
                domain,
                match ret {
                    Ok(ips) => Ok(ips),
                    Err(e) => Err(e),
                },
            )
        });
    }
    let mut ttls = vec![];

    while let Some(ret) = tasks.join_next().await {
        if let Ok((domain, ret)) = ret {
            match ret {
                Ok(ips) => {
                    let expire_time = ips.valid_until();
                    let ttl = expire_time
                        .saturating_duration_since(Instant::now())
                        .as_secs();
                    ttls.push(ttl);

                    for ip in ips.iter() {
                        match ip {
                            IpAddr::V4(ip) => {
                                v4_ips.entry(domain).or_insert_with(Vec::new).push(ip);
                                max_v4_domain_len = max_v4_domain_len.max(domain.len());
                                max_v4_ip_len = max_v4_ip_len.max(ip.to_string().len());
                            }
                            IpAddr::V6(ip) => {
                                v6_ips.entry(domain).or_insert_with(Vec::new).push(ip);
                                max_v6_domain_len = max_v6_domain_len.max(domain.len());
                                max_v6_ip_len = max_v6_ip_len.max(ip.to_string().len());
                            }
                        }
                    }
                }
                Err(e) => {
                    eprintln!("Resolve {} failed: {}", domain, e);
                }
            }
        } else {
            eprintln!("JoinError: {:?}", ret.unwrap_err());
        }
    }

    fn print_ips<T: fmt::Display>(
        ips: &HashMap<&str, Vec<T>>,
        content: &mut String,
        domain_len: usize,
        ip_len: usize,
        single: bool,
    ) {
        for domain in DOMAIN_LIST {
            let domain_ips = ips.get(domain);
            match domain_ips {
                Some(domain_ips) => {
                    if domain_ips.is_empty() {
                        content.push_str_line(&format!("# {} not resolved", domain));
                        continue;
                    }
                    if single {
                        content.push_str_line(&format!(
                            "{:w1$} {:>w2$}",
                            domain_ips[0],
                            domain,
                            w1 = ip_len,
                            w2 = domain_len
                        ));
                        continue;
                    }
                    for ip in domain_ips {
                        content.push_str_line(&format!(
                            "{:w1$} {:>w2$}",
                            ip,
                            domain,
                            w1 = ip_len,
                            w2 = domain_len
                        ));
                    }
                }
                None => {
                    content.push_str_line(&format!("# {} not resolved", domain));
                }
            }
        }
    }

    if ipv4 {
        content.push_str("\n# IPv4 addresses:\n");

        print_ips(
            &v4_ips,
            &mut content,
            max_v4_domain_len,
            max_v4_ip_len,
            single,
        );
    }

    if ipv6 {
        content.push_str_line("");
        if !v6_ips.is_empty() {
            content.push_str_line("# IPv6 addresses:");
        } else {
            content.push_str_line("# No IPv6 addresses resolved");
        }

        print_ips(
            &v6_ips,
            &mut content,
            max_v6_domain_len,
            max_v6_ip_len,
            single,
        );
    }

    content.push_str_line("####### Onenote Hosts End #######");

    let cost_time = Local::now().signed_duration_since(now).num_milliseconds();

    header.push_str_line(&format!("# Generate in: {} ms", cost_time));

    header.push_str_line(&content);

    (header, trim_mean(&mut ttls, 20.0))
}
